## Module for storing functions, classes, and methods related to querying the Yelp API

import numpy as np
import pandas as pd
import json
import requests

## Adapted from code generated by ChatGPT - revised original function.
def yelp_request(term: str, location: str, yelp_key: str, verbose: bool = True) -> dict:
    """
    Make a request to the Yelp API to search for businesses.

    Parameters:
    - term (str): The search term to query.
    - location (str): The location to search within.
    - yelp_key (str): Your Yelp API key.
    - verbose (bool): Whether to print verbose output. Default is True.

    Returns:
    - dict: A dictionary containing the JSON response from the Yelp API.
    """

    url = 'https://api.yelp.com/v3/businesses/search'

    headers = {
        'Authorization': f'Bearer {yelp_key}',
    }

    url_params = {
        'term': term.replace(' ', '+'),
        'location': location.replace(' ', '+'),
        'limit': 50
    }

    try:
        response = requests.get(url, headers=headers, params=url_params)
        response.raise_for_status()  # Raise an exception for 4XX or 5XX status codes
        if verbose:
            print(response)
            print(type(response.text))
            print(response.text[:1000])
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error: {e}")
        return {}


## Adapted from code generated by ChatGPT - revised original function.
def parse_data(list_of_data: list) -> pd.DataFrame:
    """
    Parse a list of business data into a DataFrame.

    Parameters:
    - list_of_data (list): A list containing dictionaries of business data.

    Returns:
    - pd.DataFrame: A DataFrame containing parsed business data.
    """

    parsed_data = []

    for business in list_of_data:
        # Handle missing or nested keys gracefully
        price = business.get('price', np.nan)

        # Avoid hardcoding category index
        if 'categories' in business and business['categories']:
            category = business['categories'][0]
            alias = category.get('alias', '')
            title = category.get('title', '')
        else:
            alias = ''
            title = ''

        details = {
            'name': business.get('name', ''),
            'location': ' '.join(business['location']['display_address']) if 'location' in business else '',
            'Business ID': business.get('id', ''),
            'alias': alias,
            'title': title,
            'rating': business.get('rating', np.nan),
            'review_count': business.get('review_count', np.nan),
            'price': price,
            'latitude': business['coordinates']['latitude'] if 'coordinates' in business else np.nan,
            'longitude': business['coordinates']['longitude'] if 'coordinates' in business else np.nan
        }
        parsed_data.append(details)

    df_parsed_data = pd.DataFrame(parsed_data)

    return df_parsed_data


## Adapted from code generated by ChatGPT - revised original function.
def yelp_request_offset(term: str, location: str, yelp_key: str, offset: int = 0, verbose: bool = False) -> dict:
    """
    Make a request to the Yelp API to search for businesses with an offset.

    Parameters:
    - term (str): The search term to query.
    - location (str): The location to search within.
    - yelp_key (str): Your Yelp API key.
    - offset (int): The offset for paginating results. Default is 0.
    - verbose (bool): Whether to print verbose output. Default is False.

    Returns:
    - dict: A dictionary containing the JSON response from the Yelp API.
    """

    url = 'https://api.yelp.com/v3/businesses/search'

    headers = {
        'Authorization': f'Bearer {yelp_key}',
    }

    url_params = {
        'term': term.replace(' ', '+'),
        'location': location.replace(' ', '+'),
        'limit': 50,
        'offset': offset
    }

    try:
        response = requests.get(url, headers=headers, params=url_params)
        response.raise_for_status()  # Raise an exception for 4XX or 5XX status codes
        if verbose:
            print(response)
            print(type(response.text))
            print(response.text[:1000])
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error: {e}")
        return {}


## Adapted from code generated by ChatGPT - revised original function.

def get_full_data(term: str, location: str, yelp_key: str, file_name: str = 'data/wineries_raw.csv') -> pd.DataFrame:
    """
    Requests all results from Yelp API, saves as a .csv, and returns a DataFrame.

    Parameters:
    - term (str): The search term to query.
    - location (str): The location to search within.
    - yelp_key (str): Your Yelp API key.
    - file_name (str): The filename for the CSV file to save the data. Default is 'data/wineries_raw.csv'.

    Returns:
    - pd.DataFrame: A DataFrame containing parsed business data.
    """

    try:
        # Check if the file already exists
        with open(file_name, 'x'):
            pass
    except FileExistsError:
        print(f"File '{file_name}' already exists.")

    # Process first request to Yelp API and calculate number of pages 
    results = yelp_request_offset(term, location, yelp_key, offset=0, verbose=False)
    num_pages = (results.get('total', 0) // 50) + 1
    
    # Print out confirmation feedback
    print(f'For {term} and {location}: ')
    print(f"    Total number of results: {results.get('total', 0)}.")
    print(f'    Total number of pages: {num_pages}.')

    # Create offset for additional results
    offset = 0

    # Retrieves remaining pages
    for num in range(num_pages):
        try:
            # Process API request
            results = yelp_request_offset(term, location, yelp_key, offset=offset, verbose=False)
            
            # From results, take values from "businesses" key and save
            parsed_results = parse_data(results.get('businesses', []))
          
            # Save resulting DF to .csv from top
            with open(file_name, 'a') as file:
                parsed_results.to_csv(file, mode='a', index=False, header=(num == 0))
            
            # Increase offset to move to next "page" of data
            offset += 50
            
        except (KeyError, IndexError) as e:
            # If error, print where the error happens
            print(f'Error on page {num}: {e}')
            # Then break the loop to avoid infinite retries
            break

    return parsed_results


def clean_data(existing_dataframe, raw_data_path, cleaned_data_path):
    '''- Requires data from either an existing dataframe or an existing .csv file
    - Takes raw business data from the Yelp API and filters for the top two
    aliases (focusing on "wineries" and "winetastingrooms").
    '''

    if existing_dataframe is None:
        # Read in businesses
        df1 = pd.read_csv(raw_data_path, header = 1)

    else:
        df1 = existing_dataframe

    alias_index = df1['alias'].value_counts()[:2].index
    print(alias_index)
    
    # Filtering rows based on condition

    df2 = df1[df1['alias'].isin(alias_index)]
    
    # Resetting index
    df2.reset_index(drop=True, inplace=True)


def convert_price(dataframe, filepath):
    ''' - Requires a dataframe with the 'price' column elements being NaN, $, $$, or $$$.
    - Takes a pre-existing dataframe and adds a column to store the conversion from $ to an integer.'''
    
    # Converting $s to integers, then saving to new column.
    dataframe['price_converted'] = dataframe.loc[:,'price'].map({np.nan:0, '$':1, '$$':2, '$$$':3})
    
    
    # Saves results to new file
    dataframe.to_csv(filepath,index = False)
    
    return dataframe
    df2.to_csv(cleaned_data_path,index = False)
       
    print(f"Saved to {cleaned_data_path}.")
    
    return df2


def get_reviews(business_ID, yelp_key, verbose=False):
    '''Adapted from Yelp API Lab: https://github.com/BenJMcCarty/dsc-yelp-api-lab/tree/solution'''
    
    url = 'https://api.yelp.com/v3/businesses/'+ business_ID + '/reviews'

    headers = {
            'Authorization': 'Bearer {}'.format(yelp_key),
        }

    response = requests.get(url, headers=headers)

    if verbose == True:
        print(response)
        print(type(response.text))
        print(response.text[:1000])


    return response.json()


def parse_reviews(review):
    '''Adapted from Tyrell's code'''  

    
    # Loop through each review in the list of reviews
    # Add specific k:v pairs to a dictionary      
    details = {
        'Reviewer Name': review['user']['name'],
        'Review Rating': review['rating'],
        'Review Text': review['text'],
        'Time Created': review['time_created']
        }


    # Create a DataFrame from the resulting dictionary
    
    df_parsed_reviews = pd.DataFrame.from_dict([details])
   
    return df_parsed_reviews


def get_all_reviews(list_of_biz_ids, yelp_key, file_name = 'data/hotel_reviews_raw.csv'):
    '''Requests all review results for given business IDs from Yelp API; \
    saves as a .csv; and returns a DataFrame.'''
    
    # Create a starter empty DataFrame and save to .csv to store data.    
    blank_df = pd.DataFrame(columns= ['Reviewer Name', 'Review Rating', 
                                      'Review Text', 'Time Created', 
                                      'Business ID'])
    blank_df.to_csv(file_name, index = False)
        
    for i in list_of_biz_ids:
        try:
            
            # Process API request for 3 reviews per business:
            raw_reviews = get_reviews(i, yelp_key)

            for review in raw_reviews['reviews']:
                

                # From results, take values from "Businesses" key and save
                parsed_reviews = parse_reviews(review) 

                parsed_reviews['Business ID'] = i
                
                # H2: save results to df
                parsed_reviews.to_csv(file_name, mode='a', index = False,
                                      header = False)

        except:
            # If error, print where the error happens
            print(f'Error on page {num}.')
            # Then save the results so far to the .csv
            parsed_reviews.to_csv(file_name, mode='a', index = False, 
                                  header = False)

    try:
        reviews1 = pd.read_csv(file_name)
        return reviews1
    except:
        return parsed_reviews


